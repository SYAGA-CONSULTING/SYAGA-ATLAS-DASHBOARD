<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATLAS v0.23 - Honeycomb (Zabbix Clone)</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
            background-color: #0e1418;
            color: #d1d3d4;
            line-height: 1.6;
        }
        
        /* Zabbix exact header */
        .wrapper {
            background: #0e1418;
            min-height: 100vh;
        }
        
        .header-title {
            background: #0e1418;
            border-bottom: 1px solid #282e33;
            padding: 10px 10px;
        }
        
        .header-title h1 {
            font-size: 1.75rem;
            font-weight: 400;
            color: #f2f2f2;
            margin: 0;
        }
        
        /* Zabbix dashboard container */
        .dashboard {
            padding: 10px;
        }
        
        .dashboard-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* Zabbix widget exact style */
        .dashboard-widget {
            background: #0e1418;
            border: 1px solid #282e33;
            border-radius: 2px;
        }
        
        .dashboard-widget-head {
            background: linear-gradient(to bottom, #2b3139 0%, #1f252a 100%);
            border-bottom: 1px solid #282e33;
            padding: 8px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dashboard-widget-head h4 {
            color: #f2f2f2;
            font-size: 14px;
            font-weight: 600;
            margin: 0;
        }
        
        .dashboard-widget-body {
            background: #0e1418;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }
        
        /* Zabbix exact SVG honeycomb container */
        .svg-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Exact Zabbix honeycomb styles */
        .honeycomb-cell {
            cursor: pointer;
        }
        
        .honeycomb-cell polygon {
            stroke: #282e33;
            stroke-width: 2;
            transition: opacity 0.2s;
        }
        
        .honeycomb-cell:hover polygon {
            opacity: 0.8;
            stroke: #5c7cfa;
            stroke-width: 2;
        }
        
        .honeycomb-cell text {
            fill: #ffffff;
            font-size: 11px;
            font-weight: 400;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }
        
        .honeycomb-cell .primary-label {
            font-size: 11px;
            font-weight: 600;
        }
        
        .honeycomb-cell .secondary-label {
            font-size: 16px;
            font-weight: bold;
        }
        
        /* Zabbix exact severity colors */
        .severity-ok { fill: #43A047; }
        .severity-info { fill: #7499FF; }
        .severity-warning { fill: #FFC859; }
        .severity-average { fill: #FFA059; }
        .severity-high { fill: #E97659; }
        .severity-disaster { fill: #E45959; }
        .severity-na { fill: #97AAB3; }
        
        /* Stats bar */
        .dashboard-stats {
            background: #1f252a;
            border: 1px solid #282e33;
            border-radius: 2px;
            padding: 10px;
            margin-bottom: 10px;
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .stat-label {
            color: #768895;
            font-size: 13px;
        }
        
        .stat-value {
            color: #f2f2f2;
            font-size: 14px;
            font-weight: 600;
        }
        
        /* Controls */
        .dashboard-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .btn {
            background: #2b3139;
            border: 1px solid #444a51;
            color: #d1d3d4;
            padding: 6px 12px;
            border-radius: 2px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #3d444d;
            border-color: #5c7cfa;
        }
        
        .btn.active {
            background: #5c7cfa;
            border-color: #5c7cfa;
            color: #ffffff;
        }
        
        /* Zabbix exact tooltip style */
        .overlay-dialogue {
            position: absolute;
            background: #1f252a;
            border: 1px solid #444a51;
            border-radius: 2px;
            padding: 0;
            z-index: 10000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: none;
            min-width: 200px;
        }
        
        .overlay-dialogue.visible {
            display: block;
        }
        
        .overlay-dialogue-header {
            background: linear-gradient(to bottom, #2b3139 0%, #1f252a 100%);
            border-bottom: 1px solid #444a51;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            color: #f2f2f2;
        }
        
        .overlay-dialogue-body {
            padding: 12px;
            background: #0e1418;
        }
        
        .overlay-dialogue table {
            width: 100%;
            font-size: 12px;
            color: #d1d3d4;
        }
        
        .overlay-dialogue td {
            padding: 4px 0;
            vertical-align: top;
        }
        
        .overlay-dialogue td:first-child {
            color: #768895;
            padding-right: 15px;
            white-space: nowrap;
        }
        
        .overlay-dialogue td:last-child {
            color: #f2f2f2;
            word-break: break-word;
        }
        
        .overlay-dialogue .status-ok {
            color: #43A047;
            font-weight: 600;
        }
        
        .overlay-dialogue .status-warning {
            color: #FFC859;
            font-weight: 600;
        }
        
        .overlay-dialogue .status-high {
            color: #E97659;
            font-weight: 600;
        }
        
        .overlay-dialogue .status-disaster {
            color: #E45959;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="wrapper">
        <header class="header-title">
            <h1>État des serveurs Windows</h1>
        </header>
        
        <main class="dashboard">
            <div class="dashboard-controls">
                <button class="btn active" onclick="setFilter('all')">Tous</button>
                <button class="btn" onclick="setFilter('problems')">Problèmes uniquement</button>
                <button class="btn" onclick="toggleRefresh()">Auto-refresh: ON</button>
            </div>
            
            <div class="dashboard-stats">
                <div class="stat-item">
                    <span class="stat-label">Total:</span>
                    <span class="stat-value" id="total">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">OK:</span>
                    <span class="stat-value" style="color: #43A047;" id="ok">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Problèmes:</span>
                    <span class="stat-value" style="color: #E45959;" id="problems">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Mises à jour critiques:</span>
                    <span class="stat-value" style="color: #FFA059;" id="updates">0</span>
                </div>
            </div>
            
            <div class="dashboard-grid">
                <div class="dashboard-widget">
                    <div class="dashboard-widget-head">
                        <h4>Vue globale - Honeycomb</h4>
                    </div>
                    <div class="dashboard-widget-body" style="height: 500px;">
                        <div class="svg-container">
                            <svg id="honeycomb" width="100%" height="100%" viewBox="0 0 1200 500">
                                <!-- Honeycomb cells will be generated here -->
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <!-- Zabbix-style tooltip -->
    <div id="tooltip" class="overlay-dialogue">
        <div class="overlay-dialogue-header">Détails du serveur</div>
        <div class="overlay-dialogue-body">
            <table>
                <tbody id="tooltip-content">
                    <!-- Content will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>
    
    <script>
        // Configuration exacte Zabbix
        const CELL_SIZE = 50;  // Taille d'un hexagone
        const CELL_PADDING = 2; // Espacement entre hexagones
        
        // Données serveurs
        let servers = [];
        let autoRefresh = true;
        let currentFilter = 'all';
        
        // Générer les données
        function generateServers() {
            const clients = ['SYAGA', 'LAA', 'PROVENÇALE', 'BUQUET', 'UAI', 'PHARMABEST'];
            servers = [];
            
            clients.forEach(client => {
                for (let i = 1; i <= 8; i++) {
                    const hasUpdates = Math.random() > 0.6;
                    servers.push({
                        id: `${client}-SRV${String(i).padStart(2, '0')}`,
                        client: client,
                        name: `${client.substring(0, 3)}-${i}`,
                        fullName: `${client}-SERVER-${String(i).padStart(2, '0')}`,
                        updates: hasUpdates ? Math.floor(Math.random() * 10) : 0,
                        status: hasUpdates 
                            ? (Math.random() > 0.5 ? 'warning' : 'high')
                            : 'ok',
                        ip: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
                        os: 'Windows Server 2022',
                        lastCheck: new Date().toLocaleString('fr-FR'),
                        uptime: Math.floor(Math.random() * 30) + ' jours',
                        cpu: Math.floor(Math.random() * 100),
                        memory: Math.floor(Math.random() * 100),
                        disk: Math.floor(Math.random() * 100)
                    });
                }
            });
        }
        
        // Créer un hexagone (méthode Zabbix)
        function createHexagon(x, y, size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const px = x + size * Math.cos(angle);
                const py = y + size * Math.sin(angle);
                points.push(`${px},${py}`);
            }
            return points.join(' ');
        }
        
        // Calculer la position dans la grille
        function getHexPosition(index, columns) {
            const col = index % columns;
            const row = Math.floor(index / columns);
            
            const hexWidth = CELL_SIZE * Math.sqrt(3);
            const hexHeight = CELL_SIZE * 2;
            
            // Décalage pour les rangées impaires (comme Zabbix)
            const offsetX = (row % 2) * (hexWidth / 2);
            
            const x = col * (hexWidth + CELL_PADDING) + hexWidth / 2 + offsetX + 20;
            const y = row * (hexHeight * 0.75 + CELL_PADDING) + CELL_SIZE + 20;
            
            return { x, y };
        }
        
        // Obtenir la couleur selon le statut
        function getSeverityClass(server) {
            if (server.status === 'ok') return 'severity-ok';
            if (server.status === 'warning') return 'severity-warning';
            if (server.status === 'high') return 'severity-high';
            if (server.status === 'disaster') return 'severity-disaster';
            return 'severity-na';
        }
        
        // Render honeycomb
        function renderHoneycomb() {
            const svg = document.getElementById('honeycomb');
            svg.innerHTML = '';
            
            // Filtrer les serveurs
            let displayServers = servers;
            if (currentFilter === 'problems') {
                displayServers = servers.filter(s => s.status !== 'ok');
            }
            
            // Calculer le nombre de colonnes
            const svgWidth = 1200;
            const hexWidth = CELL_SIZE * Math.sqrt(3);
            const columns = Math.floor((svgWidth - 40) / (hexWidth + CELL_PADDING));
            
            // Créer les hexagones
            displayServers.forEach((server, index) => {
                const { x, y } = getHexPosition(index, columns);
                
                // Groupe pour l'hexagone
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.classList.add('honeycomb-cell');
                g.setAttribute('data-server', server.id);
                
                // Polygone hexagonal
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', createHexagon(x, y, CELL_SIZE));
                polygon.classList.add(getSeverityClass(server));
                g.appendChild(polygon);
                
                // Texte principal (nom du serveur)
                const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text1.setAttribute('x', x);
                text1.setAttribute('y', y - 10);
                text1.classList.add('primary-label');
                text1.textContent = server.name;
                g.appendChild(text1);
                
                // Texte secondaire (nombre de mises à jour)
                const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text2.setAttribute('x', x);
                text2.setAttribute('y', y + 10);
                text2.classList.add('secondary-label');
                text2.textContent = server.updates;
                g.appendChild(text2);
                
                // Événements hover et click
                g.addEventListener('mouseenter', (e) => showTooltip(e, server));
                g.addEventListener('mouseleave', hideTooltip);
                g.addEventListener('click', () => {
                    console.log(`Clicked on ${server.id}`);
                });
                
                svg.appendChild(g);
            });
            
            updateStats();
        }
        
        // Afficher le tooltip Zabbix-style
        function showTooltip(event, server) {
            const tooltip = document.getElementById('tooltip');
            const content = document.getElementById('tooltip-content');
            
            // Obtenir le texte du statut
            let statusText = 'OK';
            let statusClass = 'status-ok';
            if (server.status === 'warning') {
                statusText = 'Avertissement';
                statusClass = 'status-warning';
            } else if (server.status === 'high') {
                statusText = 'Élevé';
                statusClass = 'status-high';
            } else if (server.status === 'disaster') {
                statusText = 'Catastrophe';
                statusClass = 'status-disaster';
            }
            
            // Créer le contenu du tooltip
            content.innerHTML = `
                <tr>
                    <td>Serveur:</td>
                    <td><strong>${server.fullName}</strong></td>
                </tr>
                <tr>
                    <td>Client:</td>
                    <td>${server.client}</td>
                </tr>
                <tr>
                    <td>Adresse IP:</td>
                    <td>${server.ip}</td>
                </tr>
                <tr>
                    <td>Système:</td>
                    <td>${server.os}</td>
                </tr>
                <tr>
                    <td>État:</td>
                    <td class="${statusClass}">${statusText}</td>
                </tr>
                <tr>
                    <td>Mises à jour:</td>
                    <td><strong>${server.updates}</strong> en attente</td>
                </tr>
                <tr>
                    <td>CPU:</td>
                    <td>${server.cpu}%</td>
                </tr>
                <tr>
                    <td>Mémoire:</td>
                    <td>${server.memory}%</td>
                </tr>
                <tr>
                    <td>Disque:</td>
                    <td>${server.disk}%</td>
                </tr>
                <tr>
                    <td>Uptime:</td>
                    <td>${server.uptime}</td>
                </tr>
                <tr>
                    <td>Dernière vérif:</td>
                    <td>${server.lastCheck}</td>
                </tr>
            `;
            
            // Positionner le tooltip
            const rect = event.target.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';
            
            // Ajuster si le tooltip sort de l'écran
            setTimeout(() => {
                const tooltipRect = tooltip.getBoundingClientRect();
                if (tooltipRect.right > window.innerWidth) {
                    tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
                }
                if (tooltipRect.bottom > window.innerHeight) {
                    tooltip.style.top = (window.innerHeight - tooltipRect.height - 10) + 'px';
                }
            }, 1);
            
            tooltip.classList.add('visible');
        }
        
        // Cacher le tooltip
        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }
        
        // Mettre à jour les statistiques
        function updateStats() {
            document.getElementById('total').textContent = servers.length;
            document.getElementById('ok').textContent = servers.filter(s => s.status === 'ok').length;
            document.getElementById('problems').textContent = servers.filter(s => s.status !== 'ok').length;
            document.getElementById('updates').textContent = servers.reduce((sum, s) => sum + s.updates, 0);
        }
        
        // Changer le filtre
        function setFilter(filter) {
            currentFilter = filter;
            document.querySelectorAll('.btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            renderHoneycomb();
        }
        
        // Toggle auto-refresh
        function toggleRefresh() {
            autoRefresh = !autoRefresh;
            event.target.textContent = `Auto-refresh: ${autoRefresh ? 'ON' : 'OFF'}`;
            event.target.classList.toggle('active', autoRefresh);
        }
        
        // Simuler des changements
        function simulateChanges() {
            if (autoRefresh) {
                servers.forEach(server => {
                    if (Math.random() < 0.1) {
                        const hasUpdates = Math.random() > 0.5;
                        server.updates = hasUpdates ? Math.floor(Math.random() * 10) : 0;
                        server.status = hasUpdates 
                            ? (Math.random() > 0.5 ? 'warning' : 'high')
                            : 'ok';
                    }
                });
                renderHoneycomb();
            }
        }
        
        // Initialisation
        window.onload = () => {
            generateServers();
            renderHoneycomb();
            setInterval(simulateChanges, 5000);
        };
    </script>
</body>
</html>